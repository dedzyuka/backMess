app/__init__.py



app/api/__init__.py



app/api/routes/__init__.py

from app.api.routes.user import router as users_router
from app.api.routes.chat import router as chats_router
from app.api.routes.contact import router as contact_router

__all__ = ["users_router","chats_router","contact_router"]

app/api/routes/chat.py

# app/api/routes/chats.py
from datetime import datetime
import logging
from fastapi import APIRouter, Depends, HTTPException, status, Header
from sqlalchemy.ext.asyncio import AsyncSession
import uuid

from app.crud.user import UserCRUD
from app.schemas.chat import (
    ChatCreate,
    ChatLeaveAllResponse,
    ChatLeaveResponse,
    ChatMemberDetailedResponse,
    ChatMembersResponse, 
    ChatResponse, 
    ChatInviteResponse,
    ChatJoinRequest,
    ChatJoinResponse,
    ChatDetailResponse,
    ChatMemberResponse
)
from app.crud.chat import ChatCRUD
from app.database import get_db
# –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ª–æ–≥–≥–µ—Ä
logger = logging.getLogger(__name__)

router = APIRouter()

async def get_device_id(x_device_id: str = Header(..., description="–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞")):  # –ù–û–í–ê–Ø DEPENDENCY!
    return x_device_id

@router.post(
    "/",
    response_model=ChatInviteResponse,
    status_code=status.HTTP_201_CREATED,
    summary="–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —á–∞—Ç",
    response_description="–ß–∞—Ç —Å–æ–∑–¥–∞–Ω –∏ –≤–æ–∑–≤—Ä–∞—â–µ–Ω invite key"
)
async def create_chat(
    chat_data: ChatCreate,
    device_id: str = Depends(get_device_id),  # –î–û–ë–ê–í–õ–ï–ù device_id!
    db: AsyncSession = Depends(get_db)
):
    """
    –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —á–∞—Ç–∞.
    
    - **name**: –ù–∞–∑–≤–∞–Ω–∏–µ —á–∞—Ç–∞
    - **creator_id**: UUID —Å–æ–∑–¥–∞—Ç–µ–ª—è —á–∞—Ç–∞
    
    –¢—Ä–µ–±—É–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-Device-ID —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.
    """
    try:
        chat_crud = ChatCRUD(db)
        chat_invite = await chat_crud.create_chat(chat_data, device_id)  # –ü–ï–†–ï–î–ê–ï–ú device_id!
        return chat_invite
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during chat creation"
        )

@router.post(
    "/{chat_id}/join",
    response_model=ChatJoinResponse,
    summary="–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —á–∞—Ç—É –ø–æ invite key",
    response_description="–£—Å–ø–µ—à–Ω–æ–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ —á–∞—Ç—É"
)
async def join_chat(
    chat_id: uuid.UUID,
    join_data: ChatJoinRequest,
    device_id: str = Depends(get_device_id),  # –î–û–ë–ê–í–õ–ï–ù device_id!
    db: AsyncSession = Depends(get_db)
):
    """
    –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É —á–∞—Ç—É.
    
    - **user_id**: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç—Å—è
    - **invite_key**: –ö–ª—é—á –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
    
    –¢—Ä–µ–±—É–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-Device-ID —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.
    """
    try:
        chat_crud = ChatCRUD(db)
        result = await chat_crud.join_chat(chat_id, join_data, device_id)  # –ü–ï–†–ï–î–ê–ï–ú device_id!
        return result
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during chat join"
        )

@router.get(
    "/",
    response_model=list[ChatResponse],
    summary="–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
    response_description="–°–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤, –≥–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –ù–ê –≠–¢–û–ú –£–°–¢–†–û–ô–°–¢–í–ï"
)
async def get_user_chats(
    user_id: uuid.UUID,
    device_id: str = Depends(get_device_id),  # –î–û–ë–ê–í–õ–ï–ù device_id!
    skip: int = 0,
    limit: int = 100,
    db: AsyncSession = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —á–∞—Ç—ã, –≤ –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ù–ê –≠–¢–û–ú –£–°–¢–†–û–ô–°–¢–í–ï"""
    try:
        chat_crud = ChatCRUD(db)
        chats = await chat_crud.get_user_chats(user_id, device_id, skip=skip, limit=limit)  # –ü–ï–†–ï–î–ê–ï–ú device_id!
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ ChatResponse —Å –ø–æ–¥—Å—á–µ—Ç–æ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
        chat_responses = []
        for chat in chats:
            members = await chat_crud.get_chat_members(chat.chat_id)
            chat_response = ChatResponse(
                chat_id=chat.chat_id,
                name=chat.name,
                creator_id=chat.creator_id,
                created_at=chat.created_at,
                member_count=len(members)
            )
            chat_responses.append(chat_response)
        
        return chat_responses
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error retrieving user chats"
        )

@router.delete(
    "/{chat_id}/leave",
    response_model=ChatLeaveResponse,
    summary="–í—ã–π—Ç–∏ –∏–∑ —á–∞—Ç–∞",
    response_description="–£—Å–ø–µ—à–Ω—ã–π –≤—ã—Ö–æ–¥ –∏–∑ —á–∞—Ç–∞"
)
async def leave_chat(
    chat_id: uuid.UUID,
    user_id: uuid.UUID,  # –ë—É–¥–µ–º –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –∫–∞–∫ query –ø–∞—Ä–∞–º–µ—Ç—Ä
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –í—ã–π—Ç–∏ –∏–∑ —á–∞—Ç–∞.
    
    - **chat_id**: UUID —á–∞—Ç–∞
    - **user_id**: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (query –ø–∞—Ä–∞–º–µ—Ç—Ä)
    
    –£–¥–∞–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞ –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.
    """
    try:
        chat_crud = ChatCRUD(db)
        success = await chat_crud.leave_chat(chat_id, user_id, device_id)
        
        return ChatLeaveResponse(
            success=True,
            message="Successfully left the chat",
            chat_id=chat_id
        )
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during chat leave"
        )

@router.delete(
    "/leave_all",
    response_model=ChatLeaveAllResponse,
    summary="–í—ã–π—Ç–∏ –∏–∑ –≤—Å–µ—Ö —á–∞—Ç–æ–≤",
    response_description="–£—Å–ø–µ—à–Ω—ã–π –≤—ã—Ö–æ–¥ –∏–∑ –≤—Å–µ—Ö —á–∞—Ç–æ–≤"
)
async def leave_all_chats(
    user_id: uuid.UUID,  # Query –ø–∞—Ä–∞–º–µ—Ç—Ä
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –í—ã–π—Ç–∏ –∏–∑ –≤—Å–µ—Ö —á–∞—Ç–æ–≤.
    
    - **user_id**: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (query –ø–∞—Ä–∞–º–µ—Ç—Ä)
    
    –£–¥–∞–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≤—Å–µ—Ö —á–∞—Ç–æ–≤ –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.
    """
    try:
        chat_crud = ChatCRUD(db)
        result = await chat_crud.leave_all_chats(user_id, device_id)
        
        return ChatLeaveAllResponse(
            success=True,
            message=result["message"],
            left_chats=result["left_chats"]
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during leaving all chats"
        )

@router.get(
    "/{chat_id}/members/detailed",
    response_model=ChatMembersResponse,  # –ò–°–ü–†–ê–í–õ–ï–ù–û: ChatMembersResponse –≤–º–µ—Å—Ç–æ ChatMemberDetailedResponse
    summary="–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞",
    response_description="–î–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—á–∞—Å—Ç–Ω–∏–∫–∞—Ö —á–∞—Ç–∞"
)
async def get_chat_members_detailed(
    chat_id: uuid.UUID,
    db: AsyncSession = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–±–æ –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–∞—Ö —á–∞—Ç–∞"""
    try:
        logger.info(f"API call: get_chat_members_detailed for chat {chat_id}")
        
        chat_crud = ChatCRUD(db)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —á–∞—Ç–∞
        chat = await chat_crud.get_chat(chat_id)
        if not chat:
            logger.warning(f"Chat {chat_id} not found")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Chat not found"
            )
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—á–∞—Å—Ç–Ω–∏–∫–∞—Ö
        members_data = await chat_crud.get_chat_members_detailed(chat_id)
        logger.info(f"Retrieved {len(members_data)} members from database")
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ response –º–æ–¥–µ–ª—å
        members_response = []
        for member in members_data:
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ joined_at —è–≤–ª—è–µ—Ç—Å—è datetime
                joined_at = member["joined_at"]
                if not isinstance(joined_at, datetime):
                    logger.warning(f"Invalid joined_at type for user {member['user_id']}: {type(joined_at)}")
                    joined_at = datetime.utcnow()
                
                member_response = ChatMemberDetailedResponse(
                    user_id=member["user_id"],
                    nickname=member["nickname"],
                    public_key=member["public_key"],
                    joined_at=joined_at,
                    device_id=member["device_id"]
                )
                members_response.append(member_response)
                
            except Exception as e:
                logger.error(f"Error processing member {member.get('user_id', 'unknown')}: {str(e)}")
                continue  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–±–ª–µ–º–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        
        logger.info(f"Successfully created response for {len(members_response)} members")
        
        return ChatMembersResponse(
            chat_id=chat_id,
            members=members_response,
            total_members=len(members_response)
        )
        
    except HTTPException:
        logger.info("HTTPException raised, re-raising")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in get_chat_members_detailed endpoint: {str(e)}")
        logger.error(f"Exception type: {type(e)}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )

# –î–æ–ø–æ–ª–Ω—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —ç–Ω–¥–ø–æ–∏–Ω—Ç get_chat_members
@router.get(
    "/{chat_id}/members",
    response_model=list[ChatMemberResponse],
    summary="–ü–æ–ª—É—á–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞ (–±–∞–∑–æ–≤—ã–π —Å–ø–∏—Å–æ–∫)",
    response_description="–ë–∞–∑–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞"
)
async def get_chat_members(
    chat_id: uuid.UUID,
    db: AsyncSession = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å –±–∞–∑–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞"""
    try:
        chat_crud = ChatCRUD(db)
        members = await chat_crud.get_chat_members(chat_id)
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ ChatMemberResponse
        members_response = []
        for member in members:
            # TODO: –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏–∑ ChatMember
            member_response = ChatMemberResponse(
                user_id=member.user_id,
                nickname=member.nickname,
                joined_at=datetime.now()
            )
            members_response.append(member_response)
        
        return members_response
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error retrieving chat members"
        )

@router.post(
    "/{chat_id}/invite",
    response_model=dict,
    status_code=status.HTTP_200_OK,
    summary="–ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —á–∞—Ç",
    response_description="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω –≤ —á–∞—Ç"
)
async def invite_user_to_chat(
    chat_id: uuid.UUID,
    invite_data: dict,
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —á–∞—Ç.
    
    - **user_id**: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ –ø—Ä–∏–≥–ª–∞—à–∞–µ–º
    - **chat_id**: UUID —á–∞—Ç–∞ (–≤ URL)
    
    –¢–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞:
    {
        "user_id": "uuid-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
    }
    
    –¢—Ä–µ–±—É–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-Device-ID —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–≥–æ.
    """
    try:
        chat_crud = ChatCRUD(db)
        user_crud = UserCRUD(db)
        
        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —á–∞—Ç–∞
        chat = await chat_crud.get_chat(chat_id)
        if not chat:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Chat not found"
            )
        
        # 2. –ü–æ–ª—É—á–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ device_id
        inviting_user = await user_crud.get_user_by_device_id(device_id)
        if not inviting_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Inviting user not found"
            )
        
        # 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–∏–π —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —á–∞—Ç–∞
        if not await chat_crud.is_user_chat_member(chat_id, inviting_user.user_id, device_id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You are not a member of this chat"
            )
        
        # 4. –ü–æ–ª—É—á–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–∞–µ–º–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_id_str = invite_data.get("user_id")
        if not user_id_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="user_id is required in request body"
            )
        
        try:
            invited_user_id = uuid.UUID(user_id_str)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid user_id format"
            )
        
        invited_user = await user_crud.get_user(invited_user_id)
        if not invited_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Invited user not found"
            )
        
        # 5. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
        if await chat_crud.is_user_chat_member(chat_id, invited_user_id, invited_user.device_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User is already a member of this chat on this device"
            )
        
        # 6. –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —á–∞—Ç —á–µ—Ä–µ–∑ invite_user_to_chat
        result = await chat_crud.invite_user_to_chat(
            chat_id=chat_id,
            user_id=invited_user_id,
            inviter_device_id=device_id
        )
        
        logger.info(f"User {invited_user.nickname} ({invited_user_id}) invited to chat {chat_id} by {inviting_user.nickname}")
        
        return {
            "success": True,
            "message": f"User {invited_user.nickname} successfully invited to chat",
            "chat_id": chat_id,
            "invited_user_id": invited_user_id,
            "invited_user_nickname": invited_user.nickname
        }
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error inviting user to chat: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )

app/api/routes/contact.py

# app/api/routes/contact.py
from fastapi import APIRouter, Depends, HTTPException, status, Header
from sqlalchemy.ext.asyncio import AsyncSession
import uuid
import logging

from app.crud.contact import ContactCRUD
from app.crud.user import UserCRUD
from app.database import get_db
from app.schemas.contact import (
    ContactRequestCreate,
    ContactRequestResponse,
    ContactRequestListResponse,
    ContactResponse,
    ContactListResponse
)

logger = logging.getLogger(__name__)
router = APIRouter()

async def get_device_id(x_device_id: str = Header(..., description="–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞")):
    return x_device_id


@router.post(
    "/requests",
    response_model=ContactRequestResponse,
    status_code=status.HTTP_201_CREATED,
    summary="–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã",
    response_description="–ó–∞–ø—Ä–æ—Å –Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç —Å–æ–∑–¥–∞–Ω"
)
async def create_contact_request(
    request_data: ContactRequestCreate,
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã.
    
    - **to_user_id**: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–º—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
    
    –¢—Ä–µ–±—É–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-Device-ID —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è.
    """
    try:
        user_crud = UserCRUD(db)
        contact_crud = ContactCRUD(db)
        
        # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è –ø–æ device_id
        from_user = await user_crud.get_user_by_device_id(device_id)
        if not from_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found for this device"
            )
        
        # –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å
        contact_request = await contact_crud.create_contact_request(
            from_user_id=from_user.user_id,
            to_user_id=request_data.to_user_id
        )
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—É—á–∞—Ç–µ–ª–µ
        to_user = await user_crud.get_user(request_data.to_user_id)
        
        return ContactRequestResponse(
            id=contact_request.id,
            from_user_id=contact_request.from_user_id,
            from_nickname=from_user.nickname,
            to_user_id=contact_request.to_user_id,
            to_nickname=to_user.nickname if to_user else "Unknown",
            status=contact_request.status,
            created_at=contact_request.created_at
        )
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error creating contact request: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )

@router.get(
    "/requests/pending",
    response_model=ContactRequestListResponse,
    summary="–ü–æ–ª—É—á–∏—Ç—å –≤—Ö–æ–¥—è—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç",
    response_description="–°–ø–∏—Å–æ–∫ –≤—Ö–æ–¥—è—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤"
)
async def get_pending_contact_requests(
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Ö–æ–¥—è—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã"""
    try:
        user_crud = UserCRUD(db)
        contact_crud = ContactCRUD(db)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        current_user = await user_crud.get_user_by_device_id(device_id)
        if not current_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found for this device"
            )
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã
        requests = await contact_crud.get_pending_requests(current_user.user_id)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
        request_responses = []
        for req in requests:
            from_user = await user_crud.get_user(req.from_user_id)
            request_responses.append(
                ContactRequestResponse(
                    id=req.id,
                    from_user_id=req.from_user_id,
                    from_nickname=from_user.nickname if from_user else "Unknown",
                    to_user_id=req.to_user_id,
                    to_nickname=current_user.nickname,
                    status=req.status,
                    created_at=req.created_at
                )
            )
        
        return ContactRequestListResponse(
            requests=request_responses,
            total_count=len(request_responses)
        )
        
    except Exception as e:
        logger.error(f"Error getting pending requests: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )

# app/api/routes/contact.py
@router.post(
    "/requests/{request_id}/respond",
    response_model=ContactRequestResponse,
    summary="–û—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –∑–∞–ø—Ä–æ—Å –Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç",
    response_description="–ó–∞–ø—Ä–æ—Å –æ–±—Ä–∞–±–æ—Ç–∞–Ω"
)
async def respond_to_contact_request(
    request_id: uuid.UUID,
    response_data: dict,  # {"status": "accepted" –∏–ª–∏ "declined"}
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –ü—Ä–∏–Ω—è—Ç—å –∏–ª–∏ –æ—Ç–∫–ª–æ–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã.
    
    –¢–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞:
    {
        "status": "accepted" –∏–ª–∏ "declined"
    }
    """
    try:
        logger.info(f"üì• POST /contacts/requests/{request_id}/respond")
        logger.info(f"üì• Device ID: {device_id[:8]}...")
        logger.info(f"üì• Request body: {response_data}")
        logger.info(f"üì• Request ID: {request_id}")
        
        user_crud = UserCRUD(db)
        contact_crud = ContactCRUD(db)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        current_user = await user_crud.get_user_by_device_id(device_id)
        if not current_user:
            logger.warning(f"‚ùå User not found for device_id: {device_id[:8]}...")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found for this device"
            )
        
        logger.info(f"‚úÖ Current user: {current_user.nickname} ({current_user.user_id})")
        
        status_value = response_data.get("status")
        if status_value not in ["accepted", "declined"]:
            logger.error(f"‚ùå Invalid status: {status_value}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Status must be 'accepted' or 'declined'"
            )
        
        logger.info(f"‚úÖ Processing request {request_id} with status: {status_value}")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å
        contact_request = await contact_crud.respond_to_contact_request(
            request_id=request_id,
            responder_id=current_user.user_id,
            status=status_value
        )
        
        logger.info(f"‚úÖ Request processed: {contact_request.status}")
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö
        from_user = await user_crud.get_user(contact_request.from_user_id)
        to_user = await user_crud.get_user(contact_request.to_user_id)
        
        response = ContactRequestResponse(
            id=contact_request.id,
            from_user_id=contact_request.from_user_id,
            from_nickname=from_user.nickname if from_user else "Unknown",
            to_user_id=contact_request.to_user_id,
            to_nickname=to_user.nickname if to_user else "Unknown",
            status=contact_request.status,
            created_at=contact_request.created_at,
            responded_at=contact_request.responded_at
        )
        
        logger.info(f"‚úÖ Response prepared: {response}")
        return response
        
    except ValueError as e:
        logger.error(f"‚ùå ValueError in respond_to_contact_request: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"‚ùå Error responding to contact request: {str(e)}")
        import traceback
        logger.error(f"‚ùå Traceback: {traceback.format_exc()}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )

@router.get(
    "/",
    response_model=ContactListResponse,
    summary="–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤",
    response_description="–°–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
)
async def get_contacts(
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        user_crud = UserCRUD(db)
        contact_crud = ContactCRUD(db)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        current_user = await user_crud.get_user_by_device_id(device_id)
        if not current_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found for this device"
            )
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–∞–∫—Ç—ã
        contacts = await contact_crud.get_contacts(current_user.user_id)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
        contact_responses = []
        for contact_user in contacts:
            contact_responses.append(
                ContactResponse(
                    user_id=contact_user.user_id,
                    nickname=contact_user.nickname,
                    public_key=contact_user.public_key,
                    created_at=contact_user.created_at
                )
            )
        
        return ContactListResponse(
            contacts=contact_responses,
            total_count=len(contact_responses)
        )
        
    except Exception as e:
        logger.error(f"Error getting contacts: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )

@router.delete(
    "/{contact_user_id}",
    status_code=status.HTTP_200_OK,
    summary="–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç",
    response_description="–ö–æ–Ω—Ç–∞–∫—Ç —É–¥–∞–ª–µ–Ω"
)
async def remove_contact(
    contact_user_id: uuid.UUID,
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤.
    
    - **contact_user_id**: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ —É–¥–∞–ª—è–µ–º –∏–∑ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤
    """
    try:
        user_crud = UserCRUD(db)
        contact_crud = ContactCRUD(db)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        current_user = await user_crud.get_user_by_device_id(device_id)
        if not current_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found for this device"
            )
        
        # –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç
        success = await contact_crud.remove_contact(
            user_id=current_user.user_id,
            contact_user_id=contact_user_id
        )
        
        if success:
            return {"success": True, "message": "Contact removed"}
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to remove contact"
            )
        
    except Exception as e:
        logger.error(f"Error removing contact: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )

app/api/routes/user.py

# app/api/routes/user.py
from fastapi import APIRouter, Depends, HTTPException, Query, status, Header
from sqlalchemy.ext.asyncio import AsyncSession
import uuid
import logging

from app.schemas.chat import ChatInviteRequest, ChatInviteResponse
from app.schemas.user import UserCreate, UserPublicResponse, UserResponse, UserUpdate
from app.crud.user import UserCRUD
from app.crud.chat import ChatCRUD
from app.database import get_db

logger = logging.getLogger(__name__)

router = APIRouter()

async def get_device_id(x_device_id: str = Header(..., description="–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞")):
    return x_device_id

@router.post(
    "/register", 
    response_model=UserResponse,
    status_code=status.HTTP_201_CREATED,
    summary="–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
    response_description="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω"
)
async def register_user(
    user_data: UserCreate,
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∞–Ω–æ–Ω–∏–º–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Å–∏—Å—Ç–µ–º–µ.
    
    - **nickname**: –û—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (1-50 —Å–∏–º–≤–æ–ª–æ–≤)
    - **public_key**: –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –≤ PEM —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
    - **device_id**: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (–≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞)
    
    User_id –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –æ—Ç–≤–µ—Ç–µ.
    –¢—Ä–µ–±—É–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-Device-ID —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ device_id –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å device_id –≤ —Ç–µ–ª–µ
        if user_data.device_id != device_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Device ID in header does not match device ID in body"
            )
            
        user_crud = UserCRUD(db)
        user = await user_crud.create_user(user_data)
        return user
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during registration"
        )

@router.get(
    "/me",
    response_model=UserResponse,
    summary="–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ device_id –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞",
    response_description="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–µ–∫—É—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ"
)
async def get_current_user(
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ device_id –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞ X-Device-ID.
    """
    user_crud = UserCRUD(db)
    user = await user_crud.get_user_by_device_id(device_id)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found for this device"
        )
    
    return user

@router.patch(
    "/me",
    response_model=UserResponse,
    summary="–û–±–Ω–æ–≤–∏—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
    response_description="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω"
)
async def update_current_user_public_key(
    user_update: UserUpdate,
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –û–±–Ω–æ–≤–∏—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    
    - **public_key**: –ù–æ–≤—ã–π –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –≤ PEM —Ñ–æ—Ä–º–∞—Ç–µ
    """
    user_crud = UserCRUD(db)
    
    # –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user = await user_crud.get_user_by_device_id(device_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found for this device"
        )
    
    try:
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á
        user.public_key = user_update.public_key
        await db.commit()
        await db.refresh(user)
        
        logger.info(f"User {user.nickname} ({user.user_id}) updated public key for device {device_id}")
        return user
    except Exception as e:
        await db.rollback()
        logger.error(f"Error updating user public key: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error updating user"
        )

@router.get(
    "/search",
    response_model=list[UserPublicResponse],
    summary="–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ —á–∞—Å—Ç–∏—á–Ω–æ–º—É —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é nickname",
    response_description="–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —á–µ–π nickname —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–ø—Ä–æ—Å"
)
async def search_users(
    query: str = Query(..., min_length=1, max_length=50, description="–ß–∞—Å—Ç—å –Ω–∏–∫–Ω–µ–π–º–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞"),
    limit: int = Query(15, ge=1, le=50, description="–õ–∏–º–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (1-50)"),
    offset: int = Query(0, ge=0, description="–°–º–µ—â–µ–Ω–∏–µ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏"),
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ —á–∞—Å—Ç–∏—á–Ω–æ–º—É —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é nickname.
    
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —á–µ–π nickname —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–ø—Ä–æ—à–µ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É.
    
    - **query**: –ß–∞—Å—Ç—å –Ω–∏–∫–Ω–µ–π–º–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ (—Ä–µ–≥–∏—Å—Ç—Ä–æ–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ)
    - **limit**: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 15, –º–∞–∫—Å–∏–º—É–º 50)
    - **offset**: –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    
    –¢—Ä–µ–±—É–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-Device-ID —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º device_id —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω)
        user_crud = UserCRUD(db)
        current_user = await user_crud.get_user_by_device_id(device_id)
        
        if not current_user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Device not registered or unauthorized"
            )
        
        # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ —á–∞—Å—Ç–∏—á–Ω–æ–º—É nickname
        users = await user_crud.search_users_by_nickname_partial(
            partial_nickname=query,
            exclude_user_id=current_user.user_id,
            limit=limit,
            offset=offset
        )
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ UserPublicResponse
        result = []
        for user in users:
            result.append(UserPublicResponse(
                user_id=user.user_id,
                nickname=user.nickname,
                public_key=user.public_key
            ))
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error searching users: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during user search"
        )

@router.get(
    "/by-device/{device_id}",
    response_model=UserResponse,
    summary="–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ device_id",
    response_description="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ"
)
async def get_user_by_device_id(
    device_id: str,
    db: AsyncSession = Depends(get_db)
):
    """
    –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –ø–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.
    
    - **device_id**: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
    """
    user_crud = UserCRUD(db)
    user = await user_crud.get_user_by_device_id(device_id)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.get(
    "/by-nickname/{nickname}",
    response_model=UserResponse,
    summary="–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –Ω–∏–∫–Ω–µ–π–º—É",
    response_description="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ"
)
async def get_user_by_nickname(
    nickname: str,
    db: AsyncSession = Depends(get_db)
):
    """
    –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –ø–æ –Ω–∏–∫–Ω–µ–π–º—É.
    
    - **nickname**: –û—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    user_crud = UserCRUD(db)
    user = await user_crud.get_user_by_nickname(nickname)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.get(
    "/{user_id}",
    response_model=UserResponse,
    summary="–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID",
    response_description="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ"
)
async def get_user(
    user_id: uuid.UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –ø–æ –µ–≥–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É.
    
    - **user_id**: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    user_crud = UserCRUD(db)
    user = await user_crud.get_user(user_id)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

# –ó–∞–º–µ–Ω—è–µ–º invite_user_to_chat –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å—Ö–µ–º:

@router.post(
    "/{chat_id}/invite",
    response_model=ChatInviteResponse,
    status_code=status.HTTP_200_OK,
    summary="–ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —á–∞—Ç",
    response_description="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω –≤ —á–∞—Ç"
)
async def invite_user_to_chat(
    chat_id: uuid.UUID,
    invite_data: ChatInviteRequest,  # –¢–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ö–µ–º—É
    device_id: str = Depends(get_device_id),
    db: AsyncSession = Depends(get_db)
):
    """
    –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —á–∞—Ç.
    
    - **user_id**: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ –ø—Ä–∏–≥–ª–∞—à–∞–µ–º
    
    –¢—Ä–µ–±—É–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-Device-ID —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–≥–æ.
    """
    try:
        chat_crud = ChatCRUD(db)
        user_crud = UserCRUD(db)
        
        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —á–∞—Ç–∞
        chat = await chat_crud.get_chat(chat_id)
        if not chat:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Chat not found"
            )
        
        # 2. –ü–æ–ª—É—á–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ device_id
        inviting_user = await user_crud.get_user_by_device_id(device_id)
        if not inviting_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Inviting user not found"
            )
        
        # 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–∏–π —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —á–∞—Ç–∞
        if not await chat_crud.is_user_chat_member(chat_id, inviting_user.user_id, device_id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You are not a member of this chat"
            )
        
        # 4. –ü–æ–ª—É—á–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–∞–µ–º–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        invited_user = await user_crud.get_user(invite_data.user_id)
        if not invited_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Invited user not found"
            )
        
        # 5. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
        if await chat_crud.is_user_chat_member(chat_id, invite_data.user_id, invited_user.device_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User is already a member of this chat"
            )
        
        # 6. –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —á–∞—Ç
        result = await chat_crud.invite_user_to_chat(
            chat_id=chat_id,
            user_id=invite_data.user_id,
            inviter_device_id=device_id
        )
        
        logger.info(f"User {invited_user.nickname} ({invite_data.user_id}) invited to chat {chat_id} by {inviting_user.nickname}")
        
        return ChatInviteResponse(
            success=True,
            message=f"User {invited_user.nickname} successfully invited to chat",
            chat_id=chat_id,
            invited_user_id=invite_data.user_id,
            invited_user_nickname=invited_user.nickname
        )
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error inviting user to chat: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )

app/api/routes/websocket.py

# app/api/routes/websocket.py
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends
from sqlalchemy.ext.asyncio import AsyncSession
import uuid
import json
import logging
from datetime import datetime

from app.crud.contact import ContactCRUD
from app.websocket.manager import ConnectionManager
from app.database import get_db
from app.crud.user import UserCRUD
from app.crud.chat import ChatCRUD

logger = logging.getLogger(__name__)
router = APIRouter()
manager = ConnectionManager()

# –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def get_current_user(device_id: str, user_id: uuid.UUID, db: AsyncSession):
    """–ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ device_id —Å–æ–≤–ø–∞–¥–∞–µ—Ç"""
    user_crud = UserCRUD(db)
    user = await user_crud.get_user(user_id)
    
    if not user:
        logger.warning(f"User {user_id} not found")
        return None
    
    if user.device_id != device_id:
        logger.warning(f"Device ID mismatch for user {user_id}")
        return None
    
    return user

@router.websocket("/{user_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    user_id: uuid.UUID,
    x_device_id: str = None  # –ë—É–¥–µ–º –ø–æ–ª—É—á–∞—Ç—å –∏–∑ query –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
):
    """
    WebSocket endpoint –¥–ª—è –æ–±–º–µ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
    - user_id: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    - x_device_id: device_id –∏–∑ query –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ (?device_id=...)
    """
    
    # –ü–æ–ª—É—á–∞–µ–º device_id –∏–∑ query –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    query_params = dict(websocket.query_params)
    device_id = query_params.get("device_id") or x_device_id
    
    if not device_id:
        logger.error(f"No device_id provided for user {user_id}")
        await websocket.close(code=4003, reason="Device ID required")
        return
    
    logger.info(f"WebSocket connection attempt: user={user_id}, device={device_id[:8]}...")
    
    # –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ WebSocket
    await websocket.accept()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    from app.database import AsyncSessionLocal
    async with AsyncSessionLocal() as db:
        user = await get_current_user(device_id, user_id, db)
        
        if not user:
            logger.warning(f"Authentication failed for user {user_id}")
            await websocket.close(code=4001, reason="Authentication failed")
            return
    
    logger.info(f"‚úÖ WebSocket connected: {user.nickname} ({user_id})")
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
    await manager.connect(websocket, user_id, user.nickname)
    
    try:
        while True:
            # –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            try:
                data = await websocket.receive_json()
            except json.JSONDecodeError:
                logger.error("Invalid JSON received")
                continue
                
            message_type = data.get("type")
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π
            if message_type == "chat_message":
                await handle_chat_message(data, user_id, db)
                
            elif message_type == "contact_request":
                await handle_contact_request(data, user_id, db)
                
            elif message_type == "contact_accept":
                await handle_contact_accept(data, user_id, db)
                
            elif message_type == "ping":
                await websocket.send_json({"type": "pong", "timestamp": datetime.now().isoformat()})
                
            elif message_type == "message_ack":
                await handle_message_ack(data, user_id, db)
                
            else:
                logger.warning(f"Unknown message type: {message_type}")
                
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected: {user.nickname} ({user_id})")
        await manager.disconnect(user_id)
    except Exception as e:
        logger.error(f"WebSocket error for user {user_id}: {str(e)}")
        await manager.disconnect(user_id)

async def handle_chat_message(data: dict, sender_id: uuid.UUID, db: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ —á–∞—Ç–∞"""
    try:
        chat_id = uuid.UUID(data.get("chat_id"))
        content = data.get("content")
        message_id = data.get("message_id") or str(uuid.uuid4())
        timestamp = data.get("timestamp") or datetime.now().isoformat()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å - —É—á–∞—Å—Ç–Ω–∏–∫ —á–∞—Ç–∞
        chat_crud = ChatCRUD(db)
        is_member = await chat_crud.is_user_chat_member(chat_id, sender_id)
        
        if not is_member:
            logger.warning(f"User {sender_id} is not a member of chat {chat_id}")
            return
        
        # –ü–æ–ª—É—á–∞–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞
        members = await chat_crud.get_chat_members(chat_id)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏
        message_to_forward = {
            "type": "chat_message",
            "message_id": message_id,
            "chat_id": str(chat_id),
            "sender_id": str(sender_id),
            "content": content,
            "timestamp": timestamp,
            "encrypted": data.get("encrypted", True)
        }
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º –∫—Ä–æ–º–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
        for member in members:
            if member.user_id != sender_id:
                await manager.send_personal_message(message_to_forward, member.user_id)
        
        logger.info(f"Message forwarded in chat {chat_id} from {sender_id}")
        
    except Exception as e:
        logger.error(f"Error handling chat message: {str(e)}")

# app/api/routes/websocket.py
async def handle_contact_request(data: dict, sender_id: uuid.UUID, db: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –∑–∞–ø—Ä–æ—Å –Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç"""
    try:
        # 1. –ü–æ–ª—É—á–∞–µ–º recipient_id –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
        recipient_id_str = data.get("recipient_id") or data.get("recipientId")
        
        if not recipient_id_str:
            logger.warning(f"No recipient_id in data: {data}")
            return
            
        recipient_id = uuid.UUID(recipient_id_str)
        
        # 2. –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—Ä–æ—Å —Å–∞–º–æ–º—É —Å–µ–±–µ
        if sender_id == recipient_id:
            logger.warning(f"User {sender_id} tried to send contact request to themselves")
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—à–∏–±–∫—É –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é
            error_msg = {
                "type": "contact_request_error",
                "error": "Cannot send contact request to yourself",
                "timestamp": datetime.now().isoformat()
            }
            await manager.send_personal_message(error_msg, sender_id)
            return
        
        # 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—è
        user_crud = UserCRUD(db)
        recipient = await user_crud.get_user(recipient_id)
        
        if not recipient:
            logger.warning(f"Recipient {recipient_id} not found")
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—à–∏–±–∫—É –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é
            error_msg = {
                "type": "contact_request_error",
                "error": "Recipient not found",
                "timestamp": datetime.now().isoformat()
            }
            await manager.send_personal_message(error_msg, sender_id)
            return
        
        # 4. –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª–µ
        sender = await user_crud.get_user(sender_id)
        if not sender:
            logger.warning(f"Sender {sender_id} not found")
            return
        
        # 5. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è—é—Ç—Å—è –ª–∏ —É–∂–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞–º–∏
        contact_crud = ContactCRUD(db)
        try:
            existing_contact = await contact_crud.get_contacts(sender_id)
            for contact in existing_contact:
                if contact.user_id == recipient_id:
                    logger.warning(f"Users {sender_id} and {recipient_id} are already contacts")
                    error_msg = {
                        "type": "contact_request_error",
                        "error": "Users are already contacts",
                        "timestamp": datetime.now().isoformat()
                    }
                    await manager.send_personal_message(error_msg, sender_id)
                    return
        except:
            pass
        
        # 6. –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –≤ –ë–î
        request_id = uuid.uuid4()
        try:
            contact_request = await contact_crud.create_contact_request(
                from_user_id=sender_id,
                to_user_id=recipient_id
            )
            request_id = contact_request.id
        except ValueError as e:
            logger.error(f"Failed to create contact request: {str(e)}")
            error_msg = {
                "type": "contact_request_error",
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
            await manager.send_personal_message(error_msg, sender_id)
            return
        
        # 7. –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç
        contact_request_msg = {
            "type": "contact_request",
            "request_id": str(request_id),
            "sender_id": str(sender_id),
            "sender_nickname": sender.nickname,
            "sender_public_key": sender.public_key,
            "timestamp": datetime.now().isoformat()
        }
        
        logger.info(f"üì§ Contact request: {sender.nickname} ‚Üí {recipient.nickname}")
        
        # 8. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¢–û–õ–¨–ö–û –ø–æ–ª—É—á–∞—Ç–µ–ª—é
        await manager.send_personal_message(contact_request_msg, recipient_id)
        
        # 9. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é (–Ω–æ –Ω–µ –∑–∞–ø—Ä–æ—Å!)
        await manager.send_personal_message({
            "type": "contact_request_sent",
            "recipient_id": str(recipient_id),
            "recipient_nickname": recipient.nickname,
            "request_id": str(request_id),
            "timestamp": datetime.now().isoformat()
        }, sender_id)
        
        logger.info(f"‚úÖ Contact request sent successfully")
        
    except Exception as e:
        logger.error(f"Error handling contact request: {str(e)}")

async def handle_contact_accept(data: dict, sender_id: uuid.UUID, db: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞"""
    try:
        original_sender_id = uuid.UUID(data.get("original_sender_id"))
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö
        user_crud = UserCRUD(db)
        sender = await user_crud.get_user(sender_id)
        original_sender = await user_crud.get_user(original_sender_id)
        
        if not sender or not original_sender:
            logger.warning(f"Users not found: sender={sender_id}, original={original_sender_id}")
            return
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        contact_accept = {
            "type": "contact_accept",
            "accepted_user_id": str(sender_id),
            "accepted_nickname": sender.nickname,
            "accepted_public_key": sender.public_key,
            "timestamp": datetime.now().isoformat()
        }
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º—É –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é
        await manager.send_personal_message(contact_accept, original_sender_id)
        
        logger.info(f"Contact accepted: {sender.nickname} accepted request from {original_sender.nickname}")
        
    except Exception as e:
        logger.error(f"Error handling contact accept: {str(e)}")

async def handle_message_ack(data: dict, ack_sender_id: uuid.UUID, db: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è"""
    try:
        message_id = data.get("message_id")
        original_sender_id = uuid.UUID(data.get("original_sender_id"))
        
        ack_message = {
            "type": "message_ack",
            "message_id": message_id,
            "ack_sender_id": str(ack_sender_id),
            "timestamp": datetime.now().isoformat()
        }
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º—É –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é
        await manager.send_personal_message(ack_message, original_sender_id)
        
        logger.info(f"Message {message_id} acknowledged by {ack_sender_id}")
        
    except Exception as e:
        logger.error(f"Error handling message ack: {str(e)}")





app/config.py

# app/config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    PROJECT_NAME: str = "Anonymous Messenger"
    VERSION: str = "1.0.0"
    API_V1_STR: str = "/api/v1"
    
    # PostgreSQL
    POSTGRES_SERVER: str = os.getenv("POSTGRES_SERVER", "localhost")
    POSTGRES_USER: str = os.getenv("POSTGRES_USER", "postgres")
    POSTGRES_PASSWORD: str = os.getenv("POSTGRES_PASSWORD", "")
    POSTGRES_DB: str = os.getenv("POSTGRES_DB", "messenger_db")
    POSTGRES_PORT: str = os.getenv("POSTGRES_PORT", "5432")
    
    @property
    def DATABASE_URL(self) -> str:
        return "postgresql+asyncpg://localhost:5432/telegram_bot"
        # return f"postgresql+psycopg2://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_SERVER}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"

settings = Settings()

app/crud/__init__.py

# app/crud/__init__.py
from app.crud.user import UserCRUD
from app.crud.chat import ChatCRUD

__all__ = ["UserCRUD", "ChatCRUD"]

app/crud/chat.py

# app/crud/chat.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.models.chat import Chat, ChatMember
from app.models.user import User
from app.schemas.chat import ChatCreate, ChatJoinRequest, ChatJoinResponse, ChatInviteResponse, ChatResponse
import uuid
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class ChatCRUD:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_chat(self, chat_id: uuid.UUID) -> Chat | None:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–∞—Ç–µ –ø–æ ID"""
        try:
            query = select(Chat).where(Chat.chat_id == chat_id)
            result = await self.db.execute(query)
            return result.scalar_one_or_none()
        except SQLAlchemyError as e:
            logger.error(f"Error getting chat {chat_id}: {str(e)}")
            raise
    
    async def create_chat(self, chat_data: ChatCreate, device_id: str) -> ChatInviteResponse:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —á–∞—Ç –∏ –¥–æ–±–∞–≤–∏—Ç—å —Å–æ–∑–¥–∞—Ç–µ–ª—è –≤ —É—á–∞—Å—Ç–Ω–∏–∫–∏"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è-—Å–æ–∑–¥–∞—Ç–µ–ª—è
            user_query = select(User).where(User.user_id == chat_data.creator_id)
            user_result = await self.db.execute(user_query)
            creator = user_result.scalar_one_or_none()
            
            if not creator:
                raise ValueError(f"User with ID {chat_data.creator_id} not found")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ creator_id —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç device_id
            if creator.device_id != device_id:
                raise ValueError("User device_id does not match")
            
            # –°–æ–∑–¥–∞–µ–º —á–∞—Ç
            chat_id = uuid.uuid4()
            db_chat = Chat(
                chat_id=chat_id,
                name=chat_data.name,
                creator_id=chat_data.creator_id
            )
            
            self.db.add(db_chat)
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª—è –≤ —É—á–∞—Å—Ç–Ω–∏–∫–∏ —á–∞—Ç–∞ —Å –ø—Ä–∏–≤—è–∑–∫–æ–π –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É
            db_chat_member = ChatMember(
                chat_id=chat_id,
                user_id=chat_data.creator_id,
                device_id=device_id
            )
            self.db.add(db_chat_member)
            
            await self.db.commit()
            await self.db.refresh(db_chat)
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º invite key
            invite_key = str(chat_id)
            
            logger.info(f"Chat {chat_data.name} ({chat_id}) created by user {chat_data.creator_id} on device {device_id}")
            
            return ChatInviteResponse(
                chat_id=chat_id,
                invite_key=invite_key,
                created_at=db_chat.created_at
            )
            
        except IntegrityError as e:
            await self.db.rollback()
            logger.error(f"Integrity error creating chat: {str(e)}")
            raise ValueError("Chat creation failed - integrity error")
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Database error creating chat: {str(e)}")
            raise RuntimeError("Database error during chat creation")
        except Exception as e:
            await self.db.rollback()
            logger.error(f"Unexpected error creating chat: {str(e)}")
            raise
    
    async def create_chat(self, chat_data: ChatCreate, device_id: str) -> ChatInviteResponse:  # –î–û–ë–ê–í–õ–ï–ù device_id!
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —á–∞—Ç –∏ –¥–æ–±–∞–≤–∏—Ç—å —Å–æ–∑–¥–∞—Ç–µ–ª—è –≤ —É—á–∞—Å—Ç–Ω–∏–∫–∏"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è-—Å–æ–∑–¥–∞—Ç–µ–ª—è
            user_query = select(User).where(User.user_id == chat_data.creator_id)
            user_result = await self.db.execute(user_query)
            creator = user_result.scalar_one_or_none()
            
            if not creator:
                raise ValueError(f"User with ID {chat_data.creator_id} not found")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ creator_id —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç device_id
            if creator.device_id != device_id:
                raise ValueError("User device_id does not match")
            
            # –°–æ–∑–¥–∞–µ–º —á–∞—Ç
            chat_id = uuid.uuid4()
            db_chat = Chat(
                chat_id=chat_id,
                name=chat_data.name,
                creator_id=chat_data.creator_id
            )
            
            self.db.add(db_chat)
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª—è –≤ —É—á–∞—Å—Ç–Ω–∏–∫–∏ —á–∞—Ç–∞ —Å –ø—Ä–∏–≤—è–∑–∫–æ–π –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É
            db_chat_member = ChatMember(
                chat_id=chat_id,
                user_id=chat_data.creator_id,
                device_id=device_id  # –°–æ—Ö—Ä–∞–Ω—è–µ–º device_id —É—á–∞—Å—Ç–Ω–∏–∫–∞
            )
            self.db.add(db_chat_member)
            
            await self.db.commit()
            await self.db.refresh(db_chat)
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º invite key (–ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ chat_id, –ø–æ—Ç–æ–º –¥–æ–±–∞–≤–∏–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ)
            invite_key = str(chat_id)
            
            logger.info(f"Chat {chat_data.name} ({chat_id}) created by user {chat_data.creator_id} on device {device_id}")
            
            return ChatInviteResponse(
                chat_id=chat_id,
                invite_key=invite_key,
                created_at=db_chat.created_at
            )
            
        except IntegrityError as e:
            await self.db.rollback()
            logger.error(f"Integrity error creating chat: {str(e)}")
            raise ValueError("Chat creation failed - integrity error")
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Database error creating chat: {str(e)}")
            raise RuntimeError("Database error during chat creation")
        except Exception as e:
            await self.db.rollback()
            logger.error(f"Unexpected error creating chat: {str(e)}")
            raise
    
    # –í app/crud/chat.py, –æ–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–æ–¥ join_chat –∏–ª–∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥:

    async def invite_user_to_chat(self, chat_id: uuid.UUID, user_id: uuid.UUID, 
                             inviter_device_id: str, invite_key: str = None) -> dict:
        try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —á–∞—Ç–∞
            chat_query = select(Chat).where(Chat.chat_id == chat_id)
            chat_result = await self.db.execute(chat_query)
            chat = chat_result.scalar_one_or_none()
        
            if not chat:
                raise ValueError(f"Chat with ID {chat_id} not found")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_query = select(User).where(User.user_id == user_id)
            user_result = await self.db.execute(user_query)
            user = user_result.scalar_one_or_none()
        
            if not user:
                raise ValueError(f"User with ID {user_id} not found")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
            existing_member_query = select(ChatMember).where(
                and_(
                ChatMember.chat_id == chat_id, 
                ChatMember.user_id == user_id,
                ChatMember.device_id == user.device_id  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–º–µ–Ω–Ω–æ —ç—Ç–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
                )
            )
            existing_member_result = await self.db.execute(existing_member_query)
            existing_member = existing_member_result.scalar_one_or_none()
        
            if existing_member:
                raise ValueError(f"User {user_id} is already a member of chat {chat_id} on this device")
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —É—á–∞—Å—Ç–Ω–∏–∫–∏ —á–∞—Ç–∞ —Å –ø—Ä–∏–≤—è–∑–∫–æ–π –∫ –µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É
            db_chat_member = ChatMember(
                chat_id=chat_id,
                user_id=user_id,
                device_id=user.device_id  # –ò—Å–ø–æ–ª—å–∑—É–µ–º device_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            )
        
            self.db.add(db_chat_member)
            await self.db.commit()
            await self.db.refresh(db_chat_member)
        
            logger.info(f"User {user_id} invited to chat {chat_id} from device {inviter_device_id}")
        
            return {
            "chat_id": chat_id,
            "user_id": user_id,
            "joined_at": db_chat_member.joined_at,
            "status": "invited"
        }
        
        except ValueError as e:
            await self.db.rollback()
            raise
        except IntegrityError as e:
            await self.db.rollback()
            logger.error(f"Integrity error inviting user to chat: {str(e)}")
            raise ValueError("Chat invite failed - integrity error")
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Database error inviting user to chat: {str(e)}")
            raise RuntimeError("Database error during chat invite")
        except Exception as e:
            await self.db.rollback()
            logger.error(f"Unexpected error inviting user to chat: {str(e)}")
            raise
    
    async def get_user_chats(self, user_id: uuid.UUID, device_id: str, skip: int = 0, limit: int = 100) -> list[Chat]:  # –î–û–ë–ê–í–õ–ï–ù device_id!
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¢–û–õ–¨–ö–û –¥–ª—è —ç—Ç–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
        try:
            query = (
                select(Chat)
                .join(ChatMember, Chat.chat_id == ChatMember.chat_id)
                .where(
                    and_(
                        ChatMember.user_id == user_id,
                        ChatMember.device_id == device_id  # –¢–æ–ª—å–∫–æ —á–∞—Ç—ã –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
                    )
                )
                .order_by(Chat.created_at.desc())
                .offset(skip)
                .limit(limit)
            )
            result = await self.db.execute(query)
            chats = result.scalars().all()
            return chats
        except SQLAlchemyError as e:
            logger.error(f"Error getting user chats: {str(e)}")
            raise
    
    async def get_chat_members(self, chat_id: uuid.UUID, device_id: str = None) -> list[User]:  # –î–û–ë–ê–í–õ–ï–ù device_id!
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞ (–º–æ–∂–Ω–æ —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –ø–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É)"""
        try:
            query = (
                select(User)
                .join(ChatMember, User.user_id == ChatMember.user_id)
                .where(ChatMember.chat_id == chat_id)
            )
            
            if device_id:
                query = query.where(ChatMember.device_id == device_id)
                
            result = await self.db.execute(query)
            members = result.scalars().all()
            return members
        except SQLAlchemyError as e:
            logger.error(f"Error getting chat members for chat {chat_id}: {str(e)}")
            raise
    
    async def is_user_chat_member(self, chat_id: uuid.UUID, user_id: uuid.UUID, device_id: str = None) -> bool:
        try:
            query = select(ChatMember).where(
                (ChatMember.chat_id == chat_id) & 
            (ChatMember.user_id == user_id)
            )
        
            if device_id:
                query = query.where(ChatMember.device_id == device_id)
            
            result = await self.db.execute(query)
            return result.scalar_one_or_none() is not None
        except SQLAlchemyError as e:
            logger.error(f"Error checking chat membership: {str(e)}")
            raise
        
    async def leave_chat(self, chat_id: uuid.UUID, user_id: uuid.UUID, device_id: str) -> bool:
        """–í—ã–π—Ç–∏ –∏–∑ —á–∞—Ç–∞ (—É–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ)"""
        try:
            # –ù–∞—Ö–æ–¥–∏–º –∑–∞–ø–∏—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ —á–∞—Ç–∞ –¥–ª—è —ç—Ç–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            query = select(ChatMember).where(
                and_(
                    ChatMember.chat_id == chat_id,
                    ChatMember.user_id == user_id,
                    ChatMember.device_id == device_id
                )
            )
            result = await self.db.execute(query)
            chat_member = result.scalar_one_or_none()
            
            if not chat_member:
                raise ValueError(f"User {user_id} is not a member of chat {chat_id} on this device")
            
            # –£–¥–∞–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞
            await self.db.delete(chat_member)
            await self.db.commit()
            
            logger.info(f"User {user_id} left chat {chat_id} from device {device_id}")
            return True
            
        except ValueError as e:
            await self.db.rollback()
            raise
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Database error leaving chat: {str(e)}")
            raise RuntimeError("Database error during chat leave")
        except Exception as e:
            await self.db.rollback()
            logger.error(f"Unexpected error leaving chat: {str(e)}")
            raise

    async def leave_all_chats(self, user_id: uuid.UUID, device_id: str) -> dict:
        """–í—ã–π—Ç–∏ –∏–∑ –≤—Å–µ—Ö —á–∞—Ç–æ–≤ (—É–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≤—Å–µ—Ö —á–∞—Ç–æ–≤ –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ)"""
        try:
            # –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –∑–∞–ø–∏—Å–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞ —á–∞—Ç–∞ –¥–ª—è —ç—Ç–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            query = select(ChatMember).where(
                and_(
                    ChatMember.user_id == user_id,
                    ChatMember.device_id == device_id
                )
            )
            result = await self.db.execute(query)
            chat_members = result.scalars().all()
            
            if not chat_members:
                return {"left_chats": 0, "message": "User is not a member of any chats on this device"}
            
            # –£–¥–∞–ª—è–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏
            for chat_member in chat_members:
                await self.db.delete(chat_member)
            
            await self.db.commit()
            
            logger.info(f"User {user_id} left all {len(chat_members)} chats from device {device_id}")
            
            return {
                "left_chats": len(chat_members),
                "message": f"Successfully left {len(chat_members)} chats"
            }
            
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Database error leaving all chats: {str(e)}")
            raise RuntimeError("Database error during leaving all chats")
        except Exception as e:
            await self.db.rollback()
            logger.error(f"Unexpected error leaving all chats: {str(e)}")
            raise

    async def get_chat_members_detailed(self, chat_id: uuid.UUID) -> list[dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—á–∞—Å—Ç–Ω–∏–∫–∞—Ö —á–∞—Ç–∞"""
        try:
            logger.info(f"Getting detailed members for chat {chat_id}")
        
            query = (
            select(User, ChatMember.joined_at)
            .join(ChatMember, User.user_id == ChatMember.user_id)
            .where(ChatMember.chat_id == chat_id)
        )
        
            logger.info(f"Executing query: {query}")
            result = await self.db.execute(query)
            members_data = result.all()
        
            logger.info(f"Found {len(members_data)} members for chat {chat_id}")
        
            members = []
            for user, joined_at in members_data:
                logger.info(f"Processing user: {user.user_id}, joined_at: {joined_at}")
            
                members.append({
                "user_id": user.user_id,
                "nickname": user.nickname,
                "public_key": user.public_key,
                "joined_at": joined_at,
                "device_id": user.device_id  
            })
        
            logger.info(f"Successfully processed {len(members)} members")
            return members
        
        except Exception as e:
            logger.error(f"Error in get_chat_members_detailed for chat {chat_id}: {str(e)}")
            logger.error(f"Exception type: {type(e)}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")
            raise
    

app/crud/contact.py

# app/crud/contact.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, delete
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.models.contact import ContactRequest, Contact
from app.models.user import User
import uuid
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class ContactCRUD:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create_contact_request(self, from_user_id: uuid.UUID, to_user_id: uuid.UUID, request_id: uuid.UUID = None) -> ContactRequest:
        """–°–æ–∑–¥–∞—Ç—å –∑–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã"""
        try:
            logger.info(f"CRUD: Creating contact request from {from_user_id} to {to_user_id}")
            
            if request_id is None:
                request_id = uuid.uuid4()
            
            logger.info(f"CRUD: Using request_id: {request_id}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
            from_user_query = select(User).where(User.user_id == from_user_id)
            to_user_query = select(User).where(User.user_id == to_user_id)
            
            from_user = (await self.db.execute(from_user_query)).scalar_one_or_none()
            to_user = (await self.db.execute(to_user_query)).scalar_one_or_none()
            
            if not from_user or not to_user:
                raise ValueError("One or both users not found")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–ø—Ä–æ—Å –Ω–µ —Å–∞–º–æ–º—É —Å–µ–±–µ
            if from_user_id == to_user_id:
                raise ValueError("Cannot send contact request to yourself")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –∑–∞–ø—Ä–æ—Å —Å —Ç–∞–∫–∏–º ID
            existing_id_query = select(ContactRequest).where(
                ContactRequest.id == request_id
            )
            existing_id_request = (await self.db.execute(existing_id_query)).scalar_one_or_none()
            
            if existing_id_request:
                logger.warning(f"CRUD: Request with ID {request_id} already exists")
                return existing_id_request
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –∑–∞–ø—Ä–æ—Å –º–µ–∂–¥—É —ç—Ç–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
            existing_request_query = select(ContactRequest).where(
                and_(
                    ContactRequest.from_user_id == from_user_id,
                    ContactRequest.to_user_id == to_user_id,
                    ContactRequest.status == "pending"
                )
            )
            existing_request = (await self.db.execute(existing_request_query)).scalar_one_or_none()
            
            if existing_request:
                logger.warning(f"CRUD: Request already exists between these users: {existing_request.id}")
                return existing_request
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è—é—Ç—Å—è –ª–∏ —É–∂–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞–º–∏
            existing_contact_query = select(Contact).where(
                or_(
                    and_(
                        Contact.user_id == from_user_id,
                        Contact.contact_user_id == to_user_id
                    ),
                    and_(
                        Contact.user_id == to_user_id,
                        Contact.contact_user_id == from_user_id
                    )
                )
            )
            existing_contact = (await self.db.execute(existing_contact_query)).scalar_one_or_none()
            
            if existing_contact:
                raise ValueError("Users are already contacts")
            
            # –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º ID
            contact_request = ContactRequest(
                id=request_id,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π ID!
                from_user_id=from_user_id,
                to_user_id=to_user_id,
                status="pending"
            )
            
            self.db.add(contact_request)
            await self.db.commit()
            await self.db.refresh(contact_request)
            
            logger.info(f"CRUD: Contact request created with ID: {contact_request.id}")
            return contact_request
            
        except IntegrityError as e:
            await self.db.rollback()
            logger.error(f"CRUD: Integrity error creating contact request: {str(e)}")
            raise ValueError("Failed to create contact request")
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"CRUD: Database error creating contact request: {str(e)}")
            raise RuntimeError("Database error during contact request creation")
    
    async def get_pending_requests(self, user_id: uuid.UUID) -> list[ContactRequest]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Ö–æ–¥—è—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç"""
        try:
            query = select(ContactRequest).where(
                and_(
                    ContactRequest.to_user_id == user_id,
                    ContactRequest.status == "pending"
                )
            ).order_by(ContactRequest.created_at.desc())
            
            result = await self.db.execute(query)
            return result.scalars().all()
        except SQLAlchemyError as e:
            logger.error(f"Error getting pending requests: {str(e)}")
            raise
    
    async def respond_to_contact_request(
        self, 
        request_id: uuid.UUID, 
        responder_id: uuid.UUID, 
        status: str
    ) -> ContactRequest:
        """–û—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –∑–∞–ø—Ä–æ—Å –Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç (–ø—Ä–∏–Ω—è—Ç—å/–æ—Ç–∫–ª–æ–Ω–∏—Ç—å)"""
        try:
            logger.info(f"CRUD: Responding to request {request_id} with status {status}")
            
            if status not in ["accepted", "declined"]:
                raise ValueError("Status must be 'accepted' or 'declined'")
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏–º—è —Å—Ç–æ–ª–±—Ü–∞: to_user_id
            query = select(ContactRequest).where(
                and_(
                    ContactRequest.id == request_id,
                    ContactRequest.to_user_id == responder_id,  # –¢–æ–ª—å–∫–æ –ø–æ–ª—É—á–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –æ—Ç–≤–µ—Ç–∏—Ç—å
                    ContactRequest.status == "pending"
                )
            )
            
            result = await self.db.execute(query)
            contact_request = result.scalar_one_or_none()
            
            logger.info(f"CRUD: Found request: {contact_request}")
            
            if not contact_request:
                raise ValueError("Contact request not found or already processed")
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
            contact_request.status = status
            contact_request.updated_at = datetime.utcnow()
            contact_request.responded_at = datetime.utcnow()
            
            # –ï—Å–ª–∏ –ø—Ä–∏–Ω—è–ª–∏, —Å–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–∞–∫—Ç –¥–ª—è –æ–±–æ–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            if status == "accepted":
                logger.info(f"CRUD: Creating contacts between {contact_request.from_user_id} and {contact_request.to_user_id}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞
                existing_contact_query = select(Contact).where(
                    or_(
                        and_(
                            Contact.user_id == contact_request.from_user_id,
                            Contact.contact_user_id == contact_request.to_user_id
                        ),
                        and_(
                            Contact.user_id == contact_request.to_user_id,
                            Contact.contact_user_id == contact_request.from_user_id
                        )
                    )
                )
                existing_result = await self.db.execute(existing_contact_query)
                existing_contact = existing_result.scalar_one_or_none()
                
                if existing_contact:
                    logger.warning(f"CRUD: Contact already exists between these users")
                else:
                    # –ö–æ–Ω—Ç–∞–∫—Ç –¥–ª—è –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞
                    contact1 = Contact(
                        user_id=contact_request.from_user_id,
                        contact_user_id=contact_request.to_user_id
                    )
                    
                    # –ö–æ–Ω—Ç–∞–∫—Ç –¥–ª—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è
                    contact2 = Contact(
                        user_id=contact_request.to_user_id,
                        contact_user_id=contact_request.from_user_id
                    )
                    
                    self.db.add_all([contact1, contact2])
                    logger.info(f"CRUD: Contacts created")
            
            await self.db.commit()
            await self.db.refresh(contact_request)
            
            logger.info(f"CRUD: Request {request_id} {status} by {responder_id}")
            return contact_request
            
        except IntegrityError as e:
            await self.db.rollback()
            logger.error(f"CRUD: Integrity error responding to contact request: {str(e)}")
            raise ValueError("Failed to respond to contact request - integrity error")
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"CRUD: Database error responding to contact request: {str(e)}")
            raise RuntimeError("Database error during contact request response")
    
    async def get_contacts(self, user_id: uuid.UUID) -> list[User]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            query = select(User).join(
                Contact, Contact.contact_user_id == User.user_id
            ).where(
                Contact.user_id == user_id
            ).order_by(User.nickname)
            
            result = await self.db.execute(query)
            return result.scalars().all()
        except SQLAlchemyError as e:
            logger.error(f"Error getting contacts: {str(e)}")
            raise
    
    async def remove_contact(self, user_id: uuid.UUID, contact_user_id: uuid.UUID) -> bool:
        """–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç (–¥–ª—è –æ–±–æ–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)"""
        try:
            # –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç –≤ –æ–±–µ —Å—Ç–æ—Ä–æ–Ω—ã
            delete_query1 = delete(Contact).where(
                and_(
                    Contact.user_id == user_id,
                    Contact.contact_user_id == contact_user_id
                )
            )
            
            delete_query2 = delete(Contact).where(
                and_(
                    Contact.user_id == contact_user_id,
                    Contact.contact_user_id == user_id
                )
            )
            
            await self.db.execute(delete_query1)
            await self.db.execute(delete_query2)
            await self.db.commit()
            
            logger.info(f"Contact removed between {user_id} and {contact_user_id}")
            return True
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Error removing contact: {str(e)}")
            raise

app/crud/user.py

# app/crud/user.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from app.models.user import User
from app.schemas.user import UserCreate
import uuid
import logging

logger = logging.getLogger(__name__)

class UserCRUD:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_user(self, user_id: uuid.UUID) -> User | None:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID"""
        try:
            query = select(User).where(User.user_id == user_id)
            result = await self.db.execute(query)
            return result.scalar_one_or_none()
        except SQLAlchemyError as e:
            logger.error(f"Error getting user {user_id}: {str(e)}")
            raise
    
    async def get_user_by_device_id(self, device_id: str) -> User | None:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ device_id"""
        try:
            query = select(User).where(User.device_id == device_id)
            result = await self.db.execute(query)
            return result.scalar_one_or_none()
        except SQLAlchemyError as e:
            logger.error(f"Error getting user by device_id {device_id}: {str(e)}")
            raise
    
    async def get_user_by_nickname(self, nickname: str) -> User | None:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –Ω–∏–∫–Ω–µ–π–º—É"""
        try:
            query = select(User).where(User.nickname == nickname)
            result = await self.db.execute(query)
            return result.scalar_one_or_none()
        except SQLAlchemyError as e:
            logger.error(f"Error getting user by nickname {nickname}: {str(e)}")
            raise
    
    async def create_user(self, user_data: UserCreate) -> User:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º device_id
            existing_device = await self.get_user_by_device_id(user_data.device_id)
        
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º nickname
            existing_nickname = await self.get_user_by_nickname(user_data.nickname)
        
            # –°–∏—Ç—É–∞—Ü–∏—è 1: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º device_id —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if existing_device:
                # –ï—Å–ª–∏ —ç—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—ã—Ç–∞–µ—Ç—Å—è –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ–¥ —Å–≤–æ–∏–º –∂–µ nickname
                if existing_nickname and existing_nickname.user_id == existing_device.user_id:
                    # –û–±–Ω–æ–≤–ª—è–µ–º public_key –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                    if existing_device.public_key != user_data.public_key:
                        existing_device.public_key = user_data.public_key
                        await self.db.commit()
                        await self.db.refresh(existing_device)
                        logger.info(f"User {existing_device.nickname} updated public key")
                    return existing_device
                # –ï—Å–ª–∏ device_id —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –Ω–æ —Å –¥—Ä—É–≥–∏–º nickname
                else:
                    raise ValueError(f"Device {user_data.device_id} is already registered with another nickname")
        
            # –°–∏—Ç—É–∞—Ü–∏—è 2: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º nickname —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –Ω–æ device_id –¥—Ä—É–≥–æ–π
            if existing_nickname:
                # nickname —É–∂–µ –∑–∞–Ω—è—Ç –¥—Ä—É–≥–∏–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º
                raise ValueError(f"Nickname {user_data.nickname} is already taken by another device")
        
            # –°–∏—Ç—É–∞—Ü–∏—è 3: –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–æ–±–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —É–Ω–∏–∫–∞–ª—å–Ω—ã)
            user_id = uuid.uuid4()
            db_user = User(
                user_id=user_id,
                device_id=user_data.device_id,
                nickname=user_data.nickname,
                public_key=user_data.public_key
            )
        
            self.db.add(db_user)
            await self.db.commit()
            await self.db.refresh(db_user)
        
            logger.info(f"User {user_data.nickname} ({user_id}) created for device {user_data.device_id}")
            return db_user
        
        except IntegrityError as e:
            await self.db.rollback()
            logger.error(f"Integrity error creating user: {str(e)}")
            raise ValueError("User with this device_id or nickname already exists")
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Database error creating user: {str(e)}")
            raise RuntimeError("Database error during user creation")
        except Exception as e:
            await self.db.rollback()
            logger.error(f"Unexpected error creating user: {str(e)}")
            raise
    
    async def update_user_public_key(self, user_id: uuid.UUID, public_key: str) -> User | None:
        """–û–±–Ω–æ–≤–∏—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            user = await self.get_user(user_id)
            if not user:
                return None
            
            user.public_key = public_key
            await self.db.commit()
            await self.db.refresh(user)
            return user
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Error updating user {user_id}: {str(e)}")
            raise
    
    async def delete_user(self, user_id: uuid.UUID) -> bool:
        """–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            user = await self.get_user(user_id)
            if not user:
                return False
            
            await self.db.delete(user)
            await self.db.commit()
            return True
        except SQLAlchemyError as e:
            await self.db.rollback()
            logger.error(f"Error deleting user {user_id}: {str(e)}")
            raise

        
    async def search_users_by_nickname_partial(
    self, 
    partial_nickname: str, 
    exclude_user_id: uuid.UUID = None,
    limit: int = 15,
    offset: int = 0
) -> list[User]:
    
        try:
            query = select(User).where(
            User.nickname.ilike(f"%{partial_nickname}%")  # –ß–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ, —Ä–µ–≥–∏—Å—Ç—Ä–æ–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ
        )
        
        # –ò—Å–∫–ª—é—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            if exclude_user_id:
                query = query.where(User.user_id != exclude_user_id)
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ nickname –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º –ª–∏–º–∏—Ç
            query = query.order_by(User.nickname).offset(offset).limit(limit)
        
            result = await self.db.execute(query)
            users = result.scalars().all()
        
            return users
        
        except SQLAlchemyError as e:
            logger.error(f"Error searching users by partial nickname {partial_nickname}: {str(e)}")
            raise

app/database.py

# app/database.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase
from app.config import settings

class Base(DeclarativeBase):
    pass

# –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π engine
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=True,  # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ SQL –∑–∞–ø—Ä–æ—Å–æ–≤ (–æ—Ç–∫–ª—é—á–∏—Ç—å –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ)
    pool_size=20,
    max_overflow=40,
    pool_pre_ping=True,
)

# –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Å–µ—Å—Å–∏—è
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False,
    autocommit=False,
)

async def get_db() -> AsyncSession:
    """Dependency –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏ –ë–î"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

async def create_tables():
    """–°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü (–¥–ª—è —Ç–µ—Å—Ç–æ–≤/—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏)"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

app/main.py

# app/main.py
from datetime import datetime
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from app.api.routes import users_router, chats_router, contact_router
from app.api.routes.websocket import router as websocket_router


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print("üöÄ Starting Anonymous Messenger API...")
    print("üì° WebSocket available at: ws://localhost:8000/ws/{user_id}?device_id={device_id}")
    yield
    # Shutdown
    print("üëã Shutting down...")

app = FastAPI(
    title="Anonymous Messenger API",
    description="Secure anonymous messaging platform",
    version="1.0.0",
    lifespan=lifespan
)

origins = [
    "http://localhost:3000",  # React/Vue dev —Å–µ—Ä–≤–µ—Ä
    "http://127.0.0.1:3000",
    "http://0.0.0.0:8000",
    "http://localhost:8000",
]
# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–æ—É—Ç—ã
app.include_router(
    users_router,
    prefix="/api/v1/users",
    tags=["users"]
)

app.include_router(
    chats_router,
    prefix="/api/v1/chats",
    tags=["chats"]
)

# WebSocket —Ä–æ—É—Ç
app.include_router(
    websocket_router,
    prefix="/ws",
    tags=["websocket"]
)
app.include_router(
    contact_router,
    prefix="/api/v1/contacts",
    tags=["contacts"]
)

@app.get("/")
async def root():
    return {
        "message": "Anonymous Messenger API", 
        "status": "running",
        "websocket": "ws://localhost:8000/ws/{user_id}?device_id={device_id}"
    }

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

@app.get("/ws-info")
async def websocket_info():
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è—Ö"""
    from app.websocket.manager import manager
    return {
        "online_users": len(manager.active_connections),
        "offline_messages": sum(len(q) for q in manager.offline_messages.values())
    }

@app.get("/ws-info/stats")
async def get_websocket_stats():
    """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π"""
    from app.websocket.manager import manager
    
    # –°–æ–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    offline_queue_sizes = {
        str(user_id): len(messages) 
        for user_id, messages in manager.offline_messages.items()
    }
    
    return {
        "online_users": len(manager.active_connections),
        "total_offline_messages": sum(len(q) for q in manager.offline_messages.values()),
        "users_with_offline_messages": len(manager.offline_messages),
        "offline_queue_details": offline_queue_sizes,
        "server_time": datetime.now().isoformat(),
        "server_uptime": "not_implemented"  # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã
    }

app/models/__init__.py

# app/models/__init__.py
from app.models.user import User
from app.models.chat import Chat, ChatMember
from app.models.contact import ContactRequest,Contact

__all__ = ["User", "Chat", "ChatMember","ContactRequest","Contact"]

app/models/chat.py

# app/models/chat.py
from sqlalchemy import String, DateTime, ForeignKey, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship
import uuid
from datetime import datetime
from app.database import Base

class Chat(Base):
    __tablename__ = "chats"
    
    chat_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        default=uuid.uuid4
    )
    name: Mapped[str] = mapped_column(
        String(100), 
        nullable=False
    )
    creator_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("users.user_id"), 
        nullable=False
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime, 
        default=datetime.now, 
        nullable=False
    )
    
    # Relationships
    members = relationship("ChatMember", back_populates="chat", cascade="all, delete-orphan")
    creator = relationship("User")

class ChatMember(Base):
    __tablename__ = "chat_members"
    
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        default=uuid.uuid4
    )
    chat_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("chats.chat_id"), 
        nullable=False
    )
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("users.user_id"), 
        nullable=False
    )
    device_id: Mapped[str] = mapped_column(  # –ù–û–í–û–ï –ü–û–õ–ï! –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É
        String(255), 
        nullable=False,
        index=True
    )
    joined_at: Mapped[datetime] = mapped_column(
        DateTime, 
        default=datetime.utcnow, 
        nullable=False
    )
    
    # Relationships
    chat = relationship("Chat", back_populates="members")
    user = relationship("User")

app/models/contact.py

from sqlalchemy import String, DateTime, ForeignKey, UniqueConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship
import uuid
from datetime import datetime
from app.database import Base

class ContactRequest(Base):
    __tablename__ = "contact_requests"
    
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        default=uuid.uuid4
    )
    from_user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("users.user_id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    to_user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("users.user_id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    status: Mapped[str] = mapped_column(
        String(20), 
        nullable=False, 
        default="pending"
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime, 
        default=datetime.utcnow, 
        nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime, 
        default=datetime.utcnow, 
        onupdate=datetime.utcnow,
        nullable=False
    )
    
    # Relationships
    from_user = relationship("User", foreign_keys=[from_user_id])
    to_user = relationship("User", foreign_keys=[to_user_id])
    
    __table_args__ = (
        UniqueConstraint('from_user_id', 'to_user_id', name='uq_contact_request_from_to'),
    )

class Contact(Base):
    __tablename__ = "contacts"
    
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        default=uuid.uuid4
    )
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("users.user_id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    contact_user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("users.user_id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime, 
        default=datetime.utcnow, 
        nullable=False
    )
    
    # Relationships
    user = relationship("User", foreign_keys=[user_id])
    contact_user = relationship("User", foreign_keys=[contact_user_id])
    
    __table_args__ = (
        UniqueConstraint('user_id', 'contact_user_id', name='uq_user_contact'),
    )

app/models/user.py

# app/models/user.py
from sqlalchemy import String, DateTime, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
import uuid
from datetime import datetime
from app.database import Base

class User(Base):
    __tablename__ = "users"
    
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        default=uuid.uuid4
    )
    device_id: Mapped[str] = mapped_column(  # –ù–û–í–û–ï –ü–û–õ–ï!
        String(255), 
        nullable=False, 
        unique=True,
        index=True,
        default="Error"
    )
    nickname: Mapped[str] = mapped_column(
        String(50), 
        nullable=False, 
        index=True
    )
    public_key: Mapped[str] = mapped_column(
        Text, 
        nullable=False
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime, 
        default=datetime.utcnow, 
        nullable=False, 
        index=True
    )
    
    def __repr__(self):
        return f"<User {self.nickname} ({self.user_id})>"

app/schemas/__init__.py

from app.schemas.user import UserCreate, UserResponse,UserUpdate,UserPublicResponse
from app.schemas.chat import (
    ChatCreate, 
    ChatResponse, 
    ChatInviteResponse,
    ChatJoinRequest, 
    ChatJoinResponse,
    ChatMemberResponse,
    ChatLeaveResponse,
    ChatLeaveAllResponse,
    ChatMemberDetailedResponse,
    ChatMembersResponse
)
from app.schemas.contact import ContactListResponse,ContactRequestCreate,ContactRequestListResponse,ContactRequestResponse,ContactResponse

__all__ = [
    "UserCreate", "UserResponse","UserUpdate",
    "ChatCreate", "ChatResponse", "ChatInviteResponse",
    "ChatJoinRequest", "ChatJoinResponse", "ChatMemberResponse",
    "ChatLeaveResponse", "ChatLeaveAllResponse", 
    "ChatMemberDetailedResponse", "ChatMembersResponse","UserPublicResponse"
,"ContactListResponse","ContactRequestCreate","ContactRequestListResponse","ContactRequestResponse","ContactResponse"

]


app/schemas/chat.py

# app/schemas/chat.py
from pydantic import BaseModel, Field
from typing import Optional, List
import uuid
from datetime import datetime

class ChatBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="–ù–∞–∑–≤–∞–Ω–∏–µ —á–∞—Ç–∞")

class ChatCreate(ChatBase):
    creator_id: uuid.UUID = Field(..., description="UUID —Å–æ–∑–¥–∞—Ç–µ–ª—è —á–∞—Ç–∞")

class ChatResponse(ChatBase):
    chat_id: uuid.UUID
    creator_id: uuid.UUID
    created_at: datetime
    member_count: int = Field(..., description="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤")
    
    class Config:
        from_attributes = True

class ChatInviteResponse(BaseModel):
    chat_id: uuid.UUID
    invite_key: str = Field(..., description="–ö–ª—é—á –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –≤ —á–∞—Ç")
    created_at: datetime

class ChatJoinRequest(BaseModel):
    user_id: uuid.UUID = Field(..., description="UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç—Å—è")
    invite_key: str = Field(..., description="–ö–ª—é—á –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è")

class ChatJoinResponse(BaseModel):
    chat_id: uuid.UUID
    user_id: uuid.UUID
    joined_at: datetime
    status: str = Field(..., description="–°—Ç–∞—Ç—É—Å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è")

class ChatMemberResponse(BaseModel):
    user_id: uuid.UUID
    nickname: str
    joined_at: datetime

class ChatDetailResponse(ChatResponse):
    members: List[ChatMemberResponse] = Field(..., description="–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞")

class ChatLeaveResponse(BaseModel):
    success: bool = Field(..., description="–£—Å–ø–µ—à–Ω–æ—Å—Ç—å –≤—ã—Ö–æ–¥–∞ –∏–∑ —á–∞—Ç–∞")
    message: str = Field(..., description="–°–æ–æ–±—â–µ–Ω–∏–µ –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ")
    chat_id: uuid.UUID

class ChatLeaveAllResponse(BaseModel):
    success: bool = Field(..., description="–£—Å–ø–µ—à–Ω–æ—Å—Ç—å –≤—ã—Ö–æ–¥–∞ –∏–∑ –≤—Å–µ—Ö —á–∞—Ç–æ–≤")
    message: str = Field(..., description="–°–æ–æ–±—â–µ–Ω–∏–µ –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ")
    left_chats: int = Field(..., description="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–∫–∏–Ω—É—Ç—ã—Ö —á–∞—Ç–æ–≤")

class ChatMemberDetailedResponse(BaseModel):
    user_id: uuid.UUID
    nickname: str
    public_key: str
    joined_at: datetime
    device_id: str = Field(..., description="–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ —É—á–∞—Å—Ç–Ω–∏–∫–∞")

class ChatMembersResponse(BaseModel):
    chat_id: uuid.UUID
    members: List[ChatMemberDetailedResponse] = Field(..., description="–î–µ—Ç–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤")
    total_members: int = Field(..., description="–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤")

class ChatInviteRequest(BaseModel):
    user_id: uuid.UUID = Field(..., description="UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ –ø—Ä–∏–≥–ª–∞—à–∞–µ–º")

app/schemas/contact.py

# app/schemas/contact.py
from pydantic import BaseModel, Field
from typing import List, Optional
import uuid
from datetime import datetime

class ContactRequestCreate(BaseModel):
    to_user_id: uuid.UUID = Field(..., description="UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–º—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å")

class ContactRequestResponse(BaseModel):
    id: uuid.UUID
    from_user_id: uuid.UUID
    from_nickname: str
    to_user_id: uuid.UUID
    to_nickname: str
    status: str = Field(..., description="pending, accepted, declined")
    created_at: datetime
    responded_at: Optional[datetime] = None

class ContactRequestListResponse(BaseModel):
    requests: List[ContactRequestResponse]
    total_count: int

class ContactResponse(BaseModel):
    user_id: uuid.UUID
    nickname: str
    public_key: str
    created_at: datetime
    
    class Config:
        from_attributes = True

class ContactListResponse(BaseModel):
    contacts: List[ContactResponse]
    total_count: int

app/schemas/user.py

# app/schemas/user.py
from pydantic import BaseModel, Field
from typing import Optional
import uuid

class UserBase(BaseModel):
    device_id: str = Field(..., min_length=1, max_length=255, description="–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞")
    nickname: str = Field(..., min_length=1, max_length=50, description="–û—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    public_key: str = Field(..., description="–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –≤ PEM —Ñ–æ—Ä–º–∞—Ç–µ")

class UserCreate(UserBase):
    pass

class UserUpdate(BaseModel):
    public_key: str = Field(..., description="–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –≤ PEM —Ñ–æ—Ä–º–∞—Ç–µ")

class UserResponse(BaseModel):
    user_id: uuid.UUID
    device_id: str
    nickname: str
    public_key: str
    
    class Config:
        from_attributes = True

class UserPublicResponse(BaseModel):
    user_id: uuid.UUID
    nickname: str
    public_key: str
    
    class Config:
        from_attributes = True

app/security.py



app/websocket/manager.py

# app/websocket/manager.py
import asyncio
import json
from datetime import datetime
import uuid
from fastapi import WebSocket
from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)

class ConnectionManager:
    def __init__(self):
        # active_connections: {user_id: {"websocket": WebSocket, "nickname": str}}
        self.active_connections: Dict[uuid.UUID, dict] = {}
        self.offline_messages: Dict[uuid.UUID, list] = {}  # –û—á–µ—Ä–µ–¥—å –æ—Ñ–ª–∞–π–Ω —Å–æ–æ–±—â–µ–Ω–∏–π
        
    async def connect(self, websocket: WebSocket, user_id: uuid.UUID, nickname: str):
        """–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ, –µ—Å–ª–∏ –µ—Å—Ç—å
        if user_id in self.active_connections:
            try:
                old_connection = self.active_connections[user_id]["websocket"]
                await old_connection.close(code=1000, reason="New connection from same user")
            except:
                pass
        
        self.active_connections[user_id] = {
            "websocket": websocket,
            "nickname": nickname,
            "connected_at": datetime.now()
        }
        
        logger.info(f"‚úÖ User connected: {nickname} ({user_id})")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ñ–ª–∞–π–Ω —Å–æ–æ–±—â–µ–Ω–∏—è, –µ—Å–ª–∏ –µ—Å—Ç—å
        if user_id in self.offline_messages and self.offline_messages[user_id]:
            await self.send_offline_messages(user_id)
        
        # –£–≤–µ–¥–æ–º–ª—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç—ã –æ–± –æ–Ω–ª–∞–π–Ω —Å—Ç–∞—Ç—É—Å–µ
        await self.notify_contacts_online(user_id, True)
    
    async def disconnect(self, user_id: uuid.UUID):
        """–£–¥–∞–ª–∏—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        if user_id in self.active_connections:
            nickname = self.active_connections[user_id]["nickname"]
            del self.active_connections[user_id]
            
            logger.info(f"üëã User disconnected: {nickname} ({user_id})")
            
            # –£–≤–µ–¥–æ–º–ª—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç—ã –æ–± –æ—Ñ–ª–∞–π–Ω —Å—Ç–∞—Ç—É—Å–µ
            await self.notify_contacts_online(user_id, False)
    
    async def send_personal_message(self, message: dict, user_id: uuid.UUID):
    
        logger.info(f"üì§ [Manager] Sending to user_id: {user_id}")
        logger.info(f"   Message type: {message.get('type')}")
    
        if user_id in self.active_connections:
            connection_info = self.active_connections[user_id]
            logger.info(f"   User {connection_info['nickname']} is online")
        
            try:
                websocket = connection_info["websocket"]
                await websocket.send_json(message)
                logger.info(f"‚úÖ Message delivered to {connection_info['nickname']}")
                return True
            except Exception as e:
                logger.error(f"‚ùå Error sending to {user_id}: {str(e)}")
                await self.disconnect(user_id)
                return False
        else:
            logger.warning(f"‚ö†Ô∏è User {user_id} is offline")
            await self.save_offline_message(message, user_id)
            return False
    
    
    async def broadcast(self, message: dict):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Å–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"""
        disconnected_users = []
        
        for user_id, connection_data in self.active_connections.items():
            try:
                websocket = connection_data["websocket"]
                await websocket.send_json(message)
            except:
                disconnected_users.append(user_id)
        
        # –£–¥–∞–ª—è–µ–º –æ—Ç–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        for user_id in disconnected_users:
            await self.disconnect(user_id)
    
    async def send_to_chat(self, message: dict, chat_id: uuid.UUID, exclude_user_id: uuid.UUID = None):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º —á–∞—Ç–∞ (—á–µ—Ä–µ–∑ –≤–Ω–µ—à–Ω–∏–π –≤—ã–∑–æ–≤)"""
        # –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –±—É–¥–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å—Å—è –∏–∑ handle_chat_message
        # –¢–∞–º —É–∂–µ –µ—Å—Ç—å –ª–æ–≥–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞
        pass
    
    async def notify_contacts_online(self, user_id: uuid.UUID, is_online: bool):
        """–£–≤–µ–¥–æ–º–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞"""
        # TODO: –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î
        # –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º
        logger.info(f"User {user_id} is now {'online' if is_online else 'offline'}")
    
    async def save_offline_message(self, message: dict, user_id: uuid.UUID):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ—Ñ–ª–∞–π–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        if user_id not in self.offline_messages:
            self.offline_messages[user_id] = []
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –æ—á–µ—Ä–µ–¥—å (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å–æ–æ–±—â–µ–Ω–∏–π)
        if len(self.offline_messages[user_id]) >= 100:
            self.offline_messages[user_id].pop(0)
        
        self.offline_messages[user_id].append({
            "message": message,
            "timestamp": datetime.now().isoformat()
        })
        
        logger.info(f"Offline message saved for user {user_id}")
    
    async def send_offline_messages(self, user_id: uuid.UUID):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ –æ—Ñ–ª–∞–π–Ω —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        if user_id not in self.offline_messages or not self.offline_messages[user_id]:
            return
        
        messages = self.offline_messages[user_id].copy()
        self.offline_messages[user_id] = []
        
        logger.info(f"Sending {len(messages)} offline messages to user {user_id}")
        
        for msg_data in messages:
            try:
                await self.send_personal_message(msg_data["message"], user_id)
                await asyncio.sleep(0.1)  # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
            except Exception as e:
                logger.error(f"Error sending offline message: {str(e)}")
    
    def is_online(self, user_id: uuid.UUID) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –æ–Ω–ª–∞–π–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"""
        return user_id in self.active_connections
    
    def get_online_users(self) -> list:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –æ–Ω–ª–∞–π–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        return [
            {
                "user_id": user_id,
                "nickname": data["nickname"],
                "connected_at": data["connected_at"]
            }
            for user_id, data in self.active_connections.items()
        ]

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –º–µ–Ω–µ–¥–∂–µ—Ä–∞
manager = ConnectionManager()

